2020-03-28待解决问题
1、SpringBoot加载过程
2、Feign原理，SpringCloud没有优化HttpConnection创建么？
3、

ConcurrentHashMap中的get没有加锁，怎么保证线程安全的？
答：因为Node中的val使用volatile修饰，保证了有序性和可见性；并不是因为数组用volatile修饰了，volatile修饰数组，仅仅保证引用的可见性，并不保证内容可见性

Netty
http-jave基础文档中，连接池的相关概念

HttpClient为什么要单例？
OKhttpClient和HttpClient区别

Fegin、Ribbon原理

（0）redis为什么是key，value的，为什么不是支持SQL的？
（1）redis是多线程还是单线程？（回答单线程的请回吧，为什么请回，请往下看）
（2）redis的持久化开启了RDB和AOF下重启服务是如何加载的？(10个人9个回答错误)
（3）redis如果做集群该如何规划？AKF/CAP如何实现和设计？
（4）10万用户一年365天的登录情况如何用redis存储，并快速检索任意时间窗内的活跃用户？
（5）redis的5种Value类型你用过几种，能举例吗？
（6）100万并发4G数据，10万并发400G数据，如何设计Redis存储方式？

redis常见性能问题和解决方案
MySQL里有2000w数据, redis中只存20w的数据,如何保证redis中的数据都是热点数据
Memcache与Redis的区别都有哪些
redis最适合的场景
    1、会话缓存
    2、排行榜
    3、热点数据缓存
Redis的同步机制了解么、redis集群如何保证一致性（CAP理论，只能保证两者）
是否使用过Redis集群,集群的原理是什么
    1、Cluster；2、主从；3、哨兵模式
    同步机制：
    1、client节点启动后，发送sync命令到master
    2、master库fork一个线程，执行数据快照保存（RDB），并缓存期间执行的命令
    3、快照完成后，发送快照和缓存命令到从数据库
    4、从数据库接收到快照和缓存命令后，载入
    C:一致性
    A:可用性
    P:分区容错性（遇到任何一个分区出错时，任然能够保证服务的可用性，最基本要求）
线程安全的3要素：原子性、有序性、可见性

mysql悲观锁、乐观锁
悲观锁：行锁、表锁
乐观锁：mysql并没有实现乐观锁，可以通过版本号列，实现乐观锁
binlog如何实现数据备份，相关
过程：
    1、从数据库创建一个线程请求主数据库的binlog日志
    2、主数据库接收到请求后，判断请求是否包含日志位置信息，如果有，从位置读取，如果没有，从第一个日志文件开始读取
    3、从数据库接收到日志文件先保存在中继日志中，并记录位置
    4、从数据库创建线程，从中继日志中读取
动态代理，区别
MQ消费失败如何处理？消费端是拉数据，还是推数据
java的SPI
springboot加载流程
springboot常见题
java高并发常见题

共享锁
longadder
简单工厂和抽象工厂有什么区别
https://www.jianshu.com/p/d27d698802fd
spring 中的 bean 是线程安全的吗
阻塞队列和非阻塞队列
常见的阻塞队列
树：B树，B+树、二叉树、二叉平衡树、红黑树
semaphore信号量
hashmap为什么使用红黑树，好处是啥
1、读取速度快
2、
垃圾回收器和、回收算法，什么时间stop the world
回收算法：
    1、标记清理
    2、复制算法
    3、标记整理清除
    4、分代收集
找链表的倒数第K个数
方案一：
    1、循环得出链表的长度n
    2、循环读取第n-k个数，就是倒数k个数
方案二：
    1、定义两个指针，一个指针先走，走到K位置时，第二个指针开始
    2、当第一个指针为空时，此时第二个指针指向的值就是倒数第K个数

CAP理论，分区容错性的意义
大表join小表优化，如何处理数据倾斜
1、MySQL的话，尽量加where提前缩小范围

osi七层模型
一本字典找出出现频率最高的十个单词
很多数，找前10个（分治，堆排序）
    1、堆排序：升序-大顶堆，降序-小顶堆
    2、创建长度为10的链表，顺序存储前十个，后面循环比较
在浏览器输入网址后，执行的全部过程
    1、DNS域名解析，找到服务器对应的IP
    2、TCP三次握手和服务器建立连接
    3、发送http请求到服务器
    4、服务器接收并处理请求
    5、服务器返回请求结果
    6、客户端接收到请求结果数据
    7、通过四次挥手断开连接
    8、客户端渲染页面
CPU，gpu
equals和hashcode的联系
fullgc是否可以回收方法区
redis支持的数据类型，跳跃表，如何自己实现lru
快排，口述
二分查找
中序遍历
使用过哪些算法？为什么使用
如何解决高并发问题
    1、服务分布式处理
    2、热点数据缓存
    3、服务降级，避免用户涌入系统
    4、MQ异步处理，解耦系统
为什么要使用spring？
    1、解耦、方便开发
    2、IOC、AOP
    3、注解，方便实现
分布式会遇到什么问题？
    1、多服务治理、通信问题
    2、调用链路增长，性能减缓
    3、事物管理
怎么实现链表反转
    1、从头部循环，将数据写入结尾
    2、双向链表，直接反转
怎么判断链表是否有环
    1、定义个map，每次遍历的时候比较是否存在，存在的话就说明有环
    2、定义两个指针，一个一次走一步，另一个一次走两步，如果走一步的追上了走两步的，说明存在环
求数组的最大子序列和
堆和栈的定义
    堆先进先出
    栈先进后出


聚簇索引和非聚簇索引，如何用可重复度的隔离级别避免幻读问题？使用间隙锁
spring循环引用问题，如何解决
concurrenthashmap为什么放弃分段锁
fullgc接口导致接口响应慢，如何排插
多数据源如何实现
用户请求在服务器是一个请求一个线程么
tps
如何定位代码性能问题
arraylist扩容
堆排序算法
arrayqueue和linkedqueue区别
垃圾回收器
    
    线程池阻塞队列https://blog.csdn.net/nanruitao10/article/details/85114552
    
    redis数据统计如何实现-bitmap
    countdownlatch（重写AQS，实现Sync）、cycliclebrray（基于reentranlock）
    AQS原理，使用场景
    lock和Synchronized区别
        1、Synchronized基于JVM层面指令实现，lock是jdk类
        2、Synchronized无法判断锁的状态，会阻塞其他线程，lock可以判断锁的状态，选择是否阻塞
        3、Synchronized自动释放锁，lock手动释放
        4、Synchronized是可重入、非公平、不可中断锁，lock是可重入、公平或非公平、可中断锁
        5、Lock功能更多
    coutDownLatch 底层实现了QAS
    
    lock中AQS原理
    
    ReenTrantLock实现公平锁、非公平锁原理，写代码样例
    
    1、eureka客户端和服务端如何连接
    客户端启动后会去找服务端，然后注册，服务端添加该客户端的服务信息，双层map存储，第一层村服务名，第二层存服务实例，如IP，端口号等，客户端如果没有缓存的服务列表，会去读取服务端服务列表，并缓存到本地。
    客户端更新服务列表的机制：第一次注册到服务端时，没有服务列表，会从服务端拉取列表，之后客户端维护，创建新的线程，定期去服务端刷新服务列表
    2、springcloud微服务之间传递数据，是否有加密、序列化措施？
    
    Auth、JWT
    
    3、hystrix熔断之后，再次调用怎么处理？
        超过服务健康状态设置值时，熔断器开启，一段时间后，熔断器自动转换为半开状态，允许一个请求发送，如果这个请求发送成功，熔断器更新为关闭状态，否则，继续等下下次半开状态
    3、线程池超过核心线程数的线程，为什么要放在队列中，而不直接放在核心线程数中执行？
        1、等待核心线程执行完，提高线程复用性
        2、线程池创建线程，需要获取mainlock全局锁，影响并发效率，阻塞队列很好的起到缓冲
    
        
    
    4、
    
    spring IOC 加载过程
    
    aqs公平锁和非公平锁，哪个吞吐量高，为什么
    非公平锁更快，因为减少了线程等待过程。
    hashmap详细介绍
    
    GC Root节点都有哪些？
    1、方法区中静态变量引用的对象
    2、发放去中常量引用的对象
    3、栈中引用的对象
    4、native（本地方法栈）引用的对象
    
    
    1、独占锁与共享锁
    2、组合和聚合的区别
        人的身体由各种组合而成，但是可以将房子、车子通过聚合，聚合到人
    3、反射应用场景
        1、jdbc加载驱动
        2、序列化，通过反射创建对象
        3、通过类名，加载类对象
    4、线程间通信
        1、Synchronized-同步
        2、volatile
        3、pidInputStream、pidOutputStream
    5、什么是时间复杂度
        代码处理的时间长度
    6、介绍B树、B+树、红黑树
    7、jdk1.7和1.8的区别
    8、ConcurrentHashMap中size方法，1.7和1.8实现的区别
    9、介绍快速排序，是不是稳定排序，介绍所知道的稳定排序
    10、UDP、TCP、HTTP
    11、算法题：（1）最大子序列和；（2）反转链表；（3）数组中查找两数之和为K的序列对
    
二叉树层次遍历
数组存储二叉树

熟悉的垃圾回收器，工作原理

剑指offer，letcode
