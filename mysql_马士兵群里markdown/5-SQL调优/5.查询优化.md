# 5.查询优化

## 查询慢的原因

- 网络
- CPU
- IO
- 上下文切换
- 系统调用
- 生成统计信息
- 锁等待时间

## 优化数据访问

### 1、减少数据库访问的数据

通过执行计划，可以看到 MySQL 为了获得结果而访问的数据行数。当 MySQL 预估访问的行数比实际需要的数据行数（比如只需要中间5条）大得多时，说明数据库可能访问了大量必须要访问的数据，此时要想办法优化，减少数据库的访问行数以提高效率。

```mysql
-- 只需取 5 条记录，MySQL预估要扫描 200 行数据，这是全表总行数。因此需要优化
mysql> explain select actor_id from actor limit 100, 5;
+----+-------------+-------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key                 | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | actor | NULL       | index | NULL          | idx_actor_last_name | 182     | NULL |  200 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+
1 row in set (0.14 sec)

-- 优化后的情况 TODO
```

### 2、向数据库请求的数据为当且仅当

- 只查询需要的行数据

  mysql实际上是先返回全部结果再进行计算。在日常的开发中，经常是先用select语句查询大量的结果，然后获取前面的N行后关闭结果集。优化方式是在查询后面添加 `limit `

- 只取需要的列

  禁用`select *`，只取需要的列。包括在表关联查询时，也只取相同的列

- 频繁相同的请求放入缓存

  如果需要不断的重复执行相同的查询，且每次返回完全相同的数据，因此，基于这样的应用场景，我们可以将这部分数据放到查询缓存里，这样的话能够提高查询效率。

  > 在MySQL 8.0中，查询缓存已被移除，因为命中率太低且维护成本高。

## 执行过程优化

MySQL 本身提供了很多优化，这些优化体现在不同的内部组件里。

### 查询缓存

在解析一个查询语句之前，如果查询缓存是打开的，那么mysql会优先检查这个查询是否命中查询缓存中的数据。如果查询恰好命中了查询缓存，先检查权限，如果权限没有问题，那么mysql会跳过所有的阶段，直接从缓存中拿到结果并返回给客户端（MySQL 8.0之前）

### 解析器和预处理

mysql通过关键字将SQL语句进行解析，并生成一颗AST（抽象语法树），mysql解析器将使用mysql语法规则验证和解析查询，例如验证是否使用了错误的关键字或顺序是否正确等

预处理步骤会进一步检查SAT是否合法，例如表名和列名是否存在，是否有歧义，还会验证权限等

### 优化器

当AST没有问题之后，由优化器将其转成执行计划。一条查询语句可以使用非常多的执行方式，最后都可以得到对应的结果，但是不同的执行方式带来的效率是不同的，优化器的最主要目的就是要选择最有效的执行计划

mysql使用的是基于成本的优化器，在优化的时候会尝试预测一个查询使用某种查询计划时候的成本，并选择其中成本最小的一个

#### 查看成本

可以通过`show status like 'last_query_cost';`命令查看上一条 sql 语句的成本情况。

```mysql
mysql> select count(1) from actor;
+----------+
| count(1) |
+----------+
|      200 |
+----------+
1 row in set (0.21 sec)

mysql> show status like 'last_query_cost';
+-----------------+-----------+
| Variable_name   | Value     |
+-----------------+-----------+
| Last_query_cost | 20.249000 |
+-----------------+-----------+
1 row in set (0.12 sec)
```

这个成本是根据一系列统计信息计算出来的，这些信息包括但不限于：

- 每个表或者索引的个数
- 索引的基数
- 索引和数据行的长度
- 索引的分布情况

#### MySQL的误选择

MySQL 的成本估算有时会存在偏差，因此可能选择了更慢的执行计划。成本估算偏差大的原因可能如下：

- 统计信息不准确

  InnoDB 因为其 mvcc 的特性，并不能维护一个百分百准确的数据表行数统计信息

- 成本估算不等同于实际执行的成本

  有时候某个执行计划虽然需要读取更多的页，但是它的成本却更小，因为如果这些页都是顺序读或者这些页都已经在内存中的话，那么它的访问成本将很小。mysql 层面并不知道哪些页面在内存中，哪些在磁盘，所以查询之际执行过程中到底需要多少次 IO 是无法得知的

- mysql的最优可能跟你想的不一样

  mysql的优化是基于成本模型的优化，但是有可能不是最快的优化

- mysql不考虑其他并发执行的查询

- mysql不会考虑不受其控制的操作成本

  执行存储过程或者用户自定义函数的成本

### 优化策略

mysql 优化器的优化策略包括两种。

#### 静态优化

直接对AST进行分析并完成优化

#### 动态优化

动态优化与查询的上下文有关，也可能跟取值、索引对应的行数有关

mysql 对查询的静态优化只需要一次，但对动态优化在每次执行时都需要重新评估

### 优化场景

优化场景主要展示优化器会对何种情况下的 sql 语句进行如何的优化。

#### 排序优化

无论如何排序都是一个成本很高的操作，所以从性能角度出发，应尽可能避免排序或尽可能避免对大量数据进行排序

推荐利用索引进行排序，但是当不能使用索引时，就需要 mysql 自己进行排序，如果数据量小则再内存中进行，如果数据量大就需要使用磁盘，mysql中称之为 `Using filesort` 。

如果需要排序的数据量小于排序缓冲区(`show variables like '%sort_buffer_size%';`)，mysql使用内存进行**快速排序**操作；如果内存不够排序，那么 mysql 就会先将数据分块，对每个独立的块使用快速排序进行排序，并将各个块的排序结果存放再磁盘上，然后将各个排好序的块进行合并（分而治之），最后返回排序结果

mysql 的排序算法有2种：

- 两次传输排序：先仅读排序列，再对该列进行排序，最后读取整行数据

  第一次数据读取是将需要排序的字段读取出来，然后进行排序，第二次是将排好序的结果按照需要去读取数据行。

  这种方式**效率比较低**，原因是第二次读取数据时由于已经排好序，此时需要读取记录更多的是随机IO，因此读取数据成本会比较高

  两次传输的优势，在排序的时候存储尽可能少的数据，让排序缓冲区可以尽可能多的容纳行数来进行排序操作

- 单次传输排序：先读取所有行，然后根据排序列进行排序，最后返回

  先读取查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果。此方式只需要一次顺序 IO 读取所有数据，无须任何随机IO。问题在于查询的列特别多时，会占用大量的存储空间甚至无法用这种方式

当需要排序的列总大小超过`max_length_for_sort_data`定义的阈值时，mysql 会选择双次排序，反之使用单次排序，当然，可以设置`max_length_for_sort_data`参数值来决定排序的方式

#### 等值传播

如果两个列的值通过等式关联，那么 mysql 能够把其中一个列的 where 条件传递到另一个上。以下两条语句效果一样：

```sql
explain select film.film_id from film inner join film_actor using(film_id) where film.film_id > 500;

explain select film.film_id from film inner join film_actor using(film_id) where film.film_id > 500 and film_actor.film_id > 500;
```

#### 子查询优化

mysql 在某些情况下可以将子查询转换成一种效率更高的形式，从而减少对数据访问的次数，例如将经常查询的数据放入到缓存中

#### 覆盖索引

覆盖索引也体现了 mysql 的一种优化，当索引中的列包含所有查询中需要使用的列时，直接使用覆盖索引

#### 索引下推

索引下推也使 mysql 的一种优化方式，减少 IO 量从而提高效率

#### 组函数的优化

在`myisam`中，mysql 会自己维护一个表总行数的字段，插入数据时这个字段进行+1，删除数据时-1。当调用没有 where 条件的 count() 函数时，mysql会将维护的总行数字段直接返回

对于max()、min()等函数，mysql 也有自己的优化细节。例如，要找到某一列的最小值，只需要查询索引的最左端的记录即可，不需要全文扫描比较

#### 等价变换

mysql 会对 sql 语句进行等价变换，比如现有一个组合索引（a，b，c），mysql 会对 sql 语句做如下等价变换

```sql
select id from tab where c > 10 and b = 5 and a = 3;

-- 调换匹配条件顺序，使其符合最左前缀匹配原则
select id from tab where a = 3 and b = 5 and c > 10;
```

#### 关联查询

数据表的关联并不总是按照在查询中指定的顺序进行关联，决定关联顺序是优化器很重要的功能，不同的关联顺序在效率上可能相差很大

案例如下：

```mysql
-- 进行三表关联，查看执行计划会发现表读取顺序和写的关联顺序不一致，说明 mysql 做了顺序调整
mysql> explain select film.film_id,film.title,film.release_year,actor.actor_id,actor.first_name,actor.last_name from film inner join film_actor using(film_id) inner join actor using(actor_id);
+----+-------------+------------+------------+--------+------------------------+---------+---------+---------------------------+------+----------+-------------+
| id | select_type | table      | partitions | type   | possible_keys          | key     | key_len | ref                       | rows | filtered | Extra       |
+----+-------------+------------+------------+--------+------------------------+---------+---------+---------------------------+------+----------+-------------+
|  1 | SIMPLE      | actor      | NULL       | ALL    | PRIMARY                | NULL    | NULL    | NULL                      |  200 |   100.00 | NULL        |
|  1 | SIMPLE      | film_actor | NULL       | ref    | PRIMARY,idx_fk_film_id | PRIMARY | 2       | sakila.actor.actor_id     |   27 |   100.00 | Using index |
|  1 | SIMPLE      | film       | NULL       | eq_ref | PRIMARY                | PRIMARY | 2       | sakila.film_actor.film_id |    1 |   100.00 | NULL        |
+----+-------------+------------+------------+--------+------------------------+---------+---------+---------------------------+------+----------+-------------+
3 rows in set (0.12 sec)

mysql> show status like 'last_query_cost';
+-----------------+-------------+
| Variable_name   | Value       |
+-----------------+-------------+
| Last_query_cost | 2529.432367 |
+-----------------+-------------+

-- 通过 "straight_join" 关键字，强制使用 sql 语句中写的顺序进行关联
mysql> explain select straight_join film.film_id,film.title,film.release_year,actor.actor_id,actor.first_name,actor.last_name from film inner join film_actor using(film_id) inner join actor using(actor_id);
+----+-------------+------------+------------+--------+------------------------+----------------+---------+----------------------------+------+----------+-------------+
| id | select_type | table      | partitions | type   | possible_keys          | key            | key_len | ref                        | rows | filtered | Extra       |
+----+-------------+------------+------------+--------+------------------------+----------------+---------+----------------------------+------+----------+-------------+
|  1 | SIMPLE      | film       | NULL       | ALL    | PRIMARY                | NULL           | NULL    | NULL                       | 1000 |   100.00 | NULL        |
|  1 | SIMPLE      | film_actor | NULL       | ref    | PRIMARY,idx_fk_film_id | idx_fk_film_id | 2       | sakila.film.film_id        |    5 |   100.00 | Using index |
|  1 | SIMPLE      | actor      | NULL       | eq_ref | PRIMARY                | PRIMARY        | 2       | sakila.film_actor.actor_id |    1 |   100.00 | NULL        |
+----+-------------+------------+------------+--------+------------------------+----------------+---------+----------------------------+------+----------+-------------+
3 rows in set (0.12 sec)

-- 比较两者成本耗费，会发现 mysq 的优化还是还有效果的
mysql> show status like 'last_query_cost';
+-----------------+-------------+
| Variable_name   | Value       |
+-----------------+-------------+
| Last_query_cost | 2819.114608 |
+-----------------+-------------+
1 row in set (0.12 sec)
```

## 优化特定类型的查询

### count

1、对于myisam引擎，在没有任何where条件时count()函数执行比较快

2、在某些应用场景中，不需要完全精确的值，可以参考使用近似值来代替，比如可以使用explain来获取近似的值

> 在很多OLAP的应用中，需要计算某一个列值的基数，有一个计算近似值的算法叫hyperloglog

3、一般情况下，count()需要扫描大量的行才能获取精确的数据，其实很难优化。在实际操作时可以考虑使用索引覆盖扫描，或者增加汇总表，或者增加外部缓存系统。

### join

1、确保`on`或者`using`子句中的列上有索引，在创建索引的时候就要考虑到关联的顺序

当表A和表B使用列C关联的时候，如果优化器的关联顺序是B、A，那么就不需要再B表的对应列上建上索引，没有用到的索引只会带来额外的负担，一般情况下来说，只需要在关联顺序中的第二个表的相应列上创建索引

> 在mysql 8.0.18版本开始支持`hash join`，此时即使无任何索引，效率也很高

2、确保任何的`group by`和`order by`中的表达式只涉及到一个表中的列，这样mysql才有可能使用索引来优化这个过程

### sub-query

子查询会生成临时表，需要用临时表生成最终结果，因此效率很低

> join关联查询也会生成临时表，但是生成的临时表会直接作为结果返回，因此效率要优与子查询

子查询优化最重要的优化建议是尽可能使用关联查询代替

### limit

在很多应用场景中我们需要将数据进行分页，一般会使用`limit`加上偏移量的方法实现，同时加上合适的`order by`子句，如果这种方式有索引的帮助，效率通常不错，否则需要进行大量的文件排序操作。还有一种情况，当偏移量非常大的时候，需要扫描大量数据，而前面的大部分数据都会被抛弃，这样代价很高

要优化这种查询，要么在页面中限制分页的数量（从需求方面），要么优化大偏移量的性能（sql优化）

对于这种 sql 优化，最简单的办法就是尽可能地使用覆盖索引，而不是查询所有的列

```mysql
-- 常规的 limit 写法，执行计划预估需要扫描 1000 行数据
mysql> explain select film_id,description from film order by title limit 50,5;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
|  1 | SIMPLE      | film  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1000 |   100.00 | Using filesort |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
1 row in set (0.08 sec)

-- 利用索引覆盖的 limit 写法，大幅减少扫描的行数（ 55 + 1 + 55 << 1000 ）
-- 这种方式在查询小偏移量时效果较好，而对于大偏移量的sql效率更低
mysql> explain select film.film_id,film.description from film inner join (select film_id from film order by title limit 50,5) as lim using(film_id);
+----+-------------+------------+------------+--------+---------------+-----------+---------+-------------+------+----------+-------------+
| id | select_type | table      | partitions | type   | possible_keys | key       | key_len | ref         | rows | filtered | Extra       |
+----+-------------+------------+------------+--------+---------------+-----------+---------+-------------+------+----------+-------------+
|  1 | PRIMARY     | <derived2> | NULL       | ALL    | NULL          | NULL      | NULL    | NULL        |   55 |   100.00 | NULL        |
|  1 | PRIMARY     | film       | NULL       | eq_ref | PRIMARY       | PRIMARY   | 2       | lim.film_id |    1 |   100.00 | NULL        |
|  2 | DERIVED     | film       | NULL       | index  | NULL          | idx_title | 514     | NULL        |   55 |   100.00 | Using index |
+----+-------------+------------+------------+--------+---------------+-----------+---------+-------------+------+----------+-------------+
3 rows in set (0.08 sec)
```

### union

mysql总是通过创建并填充临时表的方式来执行`union`查询，因此很多优化策略在`union`查询中都没法很好的使用。经常需要手工的将`where`、`limit`、`order by`等子句下推到各个子查询中，以便优化器可以充分利用这些条件进行优化

除非确实需要服务器消除重复的行，否则一定要使用union all。使用`union`时，mysql会在查询的时候给临时表加上`distinct`的关键字，而去重操作的代价很高

### 利用用户自定义变量

利用 mysql 的用户自定义变量，有时能节约成本提高效率

#### 基本使用

```sql
set @one :=1;

set @min_actor :=(select min(actor_id) from actor);

set @last_week :=current_date-interval 1 week;
```

#### 限制

自定义变量在使用时有一些限制和注意点：

- 无法使用查询缓存
- 不能在使用常量或者标识符的地方使用自定义变量，例如表名、列名或者limit子句
- 用户自定义变量的生命周期是在一个连接中有效，所以不能用它们来做连接间的通信
- 自定义变量没有类型的概念
- mysql优化器在某些场景下可能会将这些变量优化掉，这可能导致代码不按预想地方式运行
- 赋值符号`:=`的优先级非常低，所以在使用赋值表达式时应配合括号使用
- 使用未定义变量不会产生任何语法错误，此时值为null

#### 使用案例

##### 用于排名语句

查询获取演过最多电影的前10名演员，然后根据出演电影次数做一个排名

```mysql
mysql> set @rank := 0;
Query OK, 0 rows affected (0.00 sec)

mysql> select t.actor_id, t.cnt, @rank:=@rank+1 rank from  (select actor_id,count(*) as cnt from film_actor group by actor_id order by cnt desc limit 10) t;
+----------+-----+----------------+
| actor_id | cnt | @rank:=@rank+1 |
+----------+-----+----------------+
|      107 |  42 |              1 |
|      102 |  41 |              2 |
|      198 |  40 |              3 |
|      181 |  39 |              4 |
|       23 |  37 |              5 |
|       81 |  36 |              6 |
|       37 |  35 |              7 |
|      158 |  35 |              8 |
|      106 |  35 |              9 |
|       13 |  35 |             10 |
+----------+-----+----------------+
10 rows in set (0.08 sec)
```

##### 避免重新查询刚更新的数据

当需要高效的更新一条记录的时间戳，同时希望查询当前记录中存放的时间戳是什么

```sql
-- 更新 t1 中的lastUpdated字段值为当前时间
update t1 set lastUpdated=now() where id =1;
-- 获取更新的值，还需要进行一次查询
select lastUpdated from t1 where id =1;

-- 优化之后

-- 更新值的同时，将值赋值给自定义变量
update t1 set lastupdated = now() where id = 1 and @now:=now();
-- 查询自定义变量而无需查表
select @now;
```

##### 注意变量的取值顺序

```mysql
set @rownum:=0;

-- 因为先执行 where 再执行 select，因此这个 sql 有 2条返回
mysql> select actor_id,@rownum:=@rownum+1 as cnt from actor where @rownum<=1;
+----------+-----+
| actor_id | cnt |
+----------+-----+
|       58 |   1 |
|       92 |   2 |
+----------+-----+
2 rows in set (0.10 sec)

set @rownum:=0;
-- 下面一句 sql 的返回结果可能和预期结果不符
-- 加了 order by之后，会返回了全表数据
-- 这里先执行了 order by，然后执行的 where，不符常理，所以结果不符合预期
select actor_id,@rownum:=@rownum+1 as cnt from actor where @rownum<=1 order by first_name;

set @rownum:=0;
-- 只返回第 1 条数据
select actor_id,@rownum as cnt from actor where (@rownum:=@rownum+1)<=1;
```

